<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#1a202c" />
  <meta name="theme-color" content="#1a202c" media="(prefers-color-scheme: dark)" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Mobile RTA (Pro Refactor with Off-screen Canvas)</title>

  <style>
    :root{
      --bg1:#1a202c; --bg2:#1a202c; --card:#2d3748; --text:#cbd5e1; --muted:#718096;
      --gridH:rgba(255,255,255,.08); --gridV:rgba(255,255,255,.04);
      --frame:rgba(255,255,255,.1); --label:rgba(255,255,255,.65);
      --fft:#68d391; --peak:#b794f4; --hold:#f6ad55; --bar:#68d391;
      --heatmap-color-1:#1a202c; --heatmap-color-2:#4a5568; --heatmap-color-3:#68d391;
      --heatmap-color-4:#f6ad55; --heatmap-color-5:#e53e3e;
      --dba-meter-bg-green: #48bb78;
      --dba-meter-bg-yellow: #f6ad55;
      --dba-meter-bg-orange: #ed8936;
      --dba-meter-bg-red: #e53e3e;
    }
    :root{ color-scheme:dark }
    html{ background:#1a202c }
    body{
      margin:0; height:100%;
      background:radial-gradient(1200px 600px at 70% -10%, #2d3748 10%, var(--bg1) 60%, var(--bg2) 100%);
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif;
      -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; overscroll-behavior:contain;
    }
    /* ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Safe Area ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏≠‡∏¢‡∏ö‡∏≤‡∏Å (Notch) */
    body::before,body::after{content:"";position:fixed;left:0;right:0;z-index:9999;background:#1a202c;pointer-events:none}
    body::before{top:0;height:env(safe-area-inset-top)} body::after{bottom:0;height:env(safe-area-inset-bottom)}
    @supports(padding: env(safe-area-inset-left)){
      html::before,html::after{content:"";position:fixed;top:0;bottom:0;background:#1a202c;z-index:9998;pointer-events:none}
      html::before{left:0;width:env(safe-area-inset-left)} html::after{right:0;width:env(safe-area-inset-right)}
    }

    .wrap{display:flex;flex-direction:column;gap:12px;max-width:920px;margin:0 auto;
      padding-left:calc(12px + env(safe-area-inset-left));
      padding-right:calc(12px + env(safe-area-inset-right));
      padding-top:calc(12px + env(safe-area-inset-top));
      padding-bottom:calc(12px + env(safe-area-inset-bottom));
    }
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .card{background:var(--card);border:1px solid #4a5568;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px}
    button,select,input[type=range],input[type=number]{-webkit-tap-highlight-color:transparent}
    button{background:#48bb78;border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:background-color .2s, opacity .2s;}
    button:disabled{opacity:.5;cursor:not-allowed;}
    button.secondary{background:#4a5568} button.ghost{background:#4a5568}
    label{font-size:12px;color:var(--muted)}
    .meters{display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:100%;height:320px;background:#1a202c;border-radius:12px;touch-action:none; display: block;}

    #dbMeterContainer{position:relative;background:rgba(255,255,255,.1);border-radius:999px;overflow:hidden}
    #dbMeterCanvas{height:20px;background:transparent;border-radius:999px}
    .dbLabel{position:absolute;font-size:10px;color:var(--muted);bottom:4px}

    .hint{font-size:12px;color:var(--muted)}
    .kv{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .kv div{background:#2d3748;border:1px solid #4a5568;border-radius:12px;padding:8px}
    .kv b{display:block;color:#cbd5e1;font-size:12px;margin-bottom:4px}
    .badges{display:flex;justify-content:flex-end;gap:6px;}
    .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px;color:#e5e7eb;white-space:nowrap}
    .tip{position:absolute;padding:4px 6px;font-size:12px;color:#e5e7eb;background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.12);border-radius:8px;transform:translate(-50%,-100%);pointer-events:none;white-space:nowrap;z-index:10}
    .plot{position:relative; height: 320px; margin-top: 8px;}

    .dba-values-row{display:flex;justify-content:space-between;gap:8px}
    .dba-values-row .kv-item{flex:1;background:#2d3748;border:1px solid #4a5568;border-radius:12px;padding:8px;text-align:center}
    .dba-values-row .kv-item b{display:block;color:#cbd5e1;font-size:12px;margin-bottom:4px}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Error banner -->
    <div id="errBox" class="card" style="display:none;border-color:#e53e3e;background:#1c2430">
      <b style="color:#fca5a5">‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î‡πÑ‡∏î‡πâ</b>
      <div id="errMsg" class="hint" style="color:#fca5a5">‚Äî</div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center;">
        <h2 style="margin:0 0 4px 0">my RTAs (Pro)</h2>
        <div class="row">
          <button id="btnStart">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î</button>
          <button id="btnStop" class="secondary" disabled>‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
          <button id="btnHold" class="ghost" aria-pressed="true">üìå Hold Peak: ON</button>
          <button id="btnClear" class="secondary">‚ôªÔ∏è Clear Peak</button>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <label>FFT Size
          <select id="fft">
            <option value="2048">2048</option>
            <option value="4096" selected>4096</option>
            <option value="8192">8192</option>
            <option value="16384">16384</option>
          </select>
        </label>
        <label> Smoothing <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75"></label>
        <label> Averaging <input id="avg" type="checkbox" checked></label>
        <label> A-weighting (‡πÄ‡∏î‡πÇ‡∏°‡πà) <input id="aWeight" type="checkbox"></label>
      </div>

      <div class="row">
        <label>‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏õ‡∏¥‡∏î DSP ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö (‡∏ö‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏¢‡∏≠‡∏°‡∏õ‡∏¥‡∏î):</label>
        <div class="row">
          <label>echoCancellation <input id="ec" type="checkbox" checked></label>
          <label>noiseSuppression <input id="ns" type="checkbox" checked></label>
          <label>autoGainControl <input id="agc" type="checkbox" checked></label>
        </div>
      </div>
    </div>

    <div class="meters">
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <b>RTA ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (FFT, Log Frequency)</b>
          <div class="badges">
            <span class="badge" id="fftPeakText">Peak: ‚Äî</span>
            <span class="badge" id="fftHoldText" style="display:none;">Hold: ‚Äî</span>
          </div>
        </div>
        <div class="plot">
          <canvas id="fftCanvas"></canvas>
          <div id="fftTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b id="octTitle">RTA ‡πÅ‡∏ö‡∏ö 1/12 Octave (Linear Axis)</b>
          <div class="row">
            <label style="display:flex;align-items:center;gap:6px">Range (dbFS)
              <input id="octRangeSlider" type="range" min="64" max="1023" step="1" value="255" aria-label="Octave bar range">
              <select id="octRangePreset">
                <option value="127">0‚Äì127</option>
                <option value="255" selected>0‚Äì255</option>
                <option value="511">0‚Äì511</option>
              </select>
            </label>
            <span class="hint" id="octRangeText">0‚Äì255</span>
            <span class="row" style="gap:10px;align-items:center; margin-left: auto;">
              <label>Octave
                <select id="octRes">
                  <option value="3">1/3</option>
                  <option value="6">1/6</option>
                  <option value="12" selected>1/12</option>
                </select>
              </label>
            </span>
          </div>
        </div>
        <div class="badges">
          <span class="badge" id="octPeakText">Peak: ‚Äî</span>
          <span class="badge" id="octHoldText" style="display:none;">Hold: ‚Äî</span>
        </div>
        <div class="plot">
          <canvas id="octCanvas"></canvas>
          <div id="octTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <div class="card" id="heatmapCard">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b id="heatmapTitle">Spectrogram / Heatmap</b>
          <div class="row">
            <label style="display:flex;align-items:center;gap:6px">Range (dB)
              <input id="heatmapRangeSlider" type="range" min="5" max="100" step="5" value="50" aria-label="Heatmap range">
              <select id="heatmapRangePreset">
                <option value="5">5</option> <option value="10">10</option> <option value="20">20</option> <option value="40">40</option>
                <option value="50" selected>50</option> <option value="60">60</option> <option value="80">80</option> <option value="100">100</option>
              </select>
            </label>
            <span class="hint" id="heatmapRangeText">0 to -50 dBFS</span>
          </div>
          <div class="row">
            <button id="btnToggleHeatmap" class="ghost" aria-pressed="false">Heatmap: OFF</button>
            <button id="btnHeatmapQuality" class="ghost" aria-pressed="true">üî• HD</button>
          </div>
        </div>
        <div class="plot">
          <canvas id="heatmapCanvas"></canvas>
          <div id="heatmapTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏á‡∏£‡∏ß‡∏° dB</b>
          <button id="btnResetDba" class="secondary" style="font-size:12px;padding:6px 10px;">‚ôªÔ∏è Reset AVG/MAX</button>
        </div>
        <div id="dbMeterContainer">
          <canvas id="dbMeterCanvas"></canvas>
          <span class="dbLabel" style="left:0%">0</span>
          <span class="dbLabel" style="left:28.57%">40</span>
          <span class="dbLabel" style="left:57.14%">80</span>
          <span class="dbLabel" style="left:85.71%">120</span>
          <span class="dbLabel" style="right:0">140</span>
        </div>
        <div class="dba-values-row" style="margin-top:12px;">
          <div class="kv-item"><b>Realtime (dB)</b><span id="dbRealtimeValue">‚Äî</span></div>
          <div class="kv-item"><b>AVG (dB)</b><span id="dbAvgValue">‚Äî</span></div>
          <div class="kv-item"><b>MAX (dB)</b><span id="dbMaxValue">‚Äî</span></div>
        </div>
      </div>
    </div>

    <div class="card kv">
      <div><b>‡∏£‡∏∞‡∏î‡∏±‡∏ö RMS (‡∏î‡∏¥‡∏ö dBFS)</b><span id="rms">‚Äî</span></div>
      <div><b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏û‡∏µ‡∏Ñ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì</b><span id="peak">‚Äî</span></div>
    </div>

    <div class="card row" style="justify-content:space-between;align-items:center;margin-top:0">
      <div class="hint">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏ü‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á dBFS ‡πÄ‡∏õ‡πá‡∏ô dBA (‡∏à‡∏≤‡∏Å‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)</div>
      <label>Calibration Offset (dB) <input id="calibrationOffset" type="number" min="0" step="0.1" value="100" style="width:60px;padding:4px;border-radius:6px;border:1px solid #4a5568;background:#2d3748;color:white;"></label>
    </div>

    <div class="card hint">‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î: ‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡∏°‡∏µ DSP/AGC ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÑ‡∏°‡πà‡πÅ‡∏ü‡∏•‡∏ï ‡πÉ‡∏ä‡πâ‡∏î‡∏π‡πÅ‡∏ô‡∏ß EQ ‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏°‡∏≤‡∏ï‡∏£‡∏ß‡∏±‡∏î SPL ‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û</div>
  </div>

  <script>
  (() => {
    class RTAnalyzer {
      constructor() {
        this.PAD = { L: 40, R: 10, T: 10, B: 32 };
        this.LABEL_Y = 10;
        this.HEATMAP_TIME_SLICES = 200;
        this.HEATMAP_BINS_HD = 300;
        this.HEATMAP_BINS_SD = 60;

        this.colors = {
          gridH: this.getStyle('--gridH'), gridV: this.getStyle('--gridV'),
          frame: this.getStyle('--frame'), label: this.getStyle('--label'),
          fft: this.getStyle('--fft'), peak: this.getStyle('--peak'),
          hold: this.getStyle('--hold'), bar: this.getStyle('--bar'),
          heatmap: [
            this.getStyle('--heatmap-color-1'), this.getStyle('--heatmap-color-2'),
            this.getStyle('--heatmap-color-3'), this.getStyle('--heatmap-color-4'),
            this.getStyle('--heatmap-color-5')
          ],
          dbMeter: {
            green: this.getStyle('--dba-meter-bg-green'),
            yellow: this.getStyle('--dba-meter-bg-yellow'),
            orange: this.getStyle('--dba-meter-bg-orange'),
            red: this.getStyle('--dba-meter-bg-red')
          }
        };

        this.dom = this.getDOMElements();
        
        this.state = {
          audioCtx: null, analyser: null, micSrc: null, rafId: null,
          dataArray: null, freqArray: null,
          sampleRate: 48000,
          running: false,
          holdEnabled: true,
          heatmapEnabled: false,
          heatmapIsHD: true,
          peakArray: null, peakOct: null,
          avgBuffer: null,
          octN: 12, bands: [],
          heatmapData: [], heatmapFreqBinMap: null,
          lastHeatmapUpdate: 0,
          calibrationOffset: 100,
          maxDba: -Infinity, dbaValues: [],
          octRangeMax: 255, heatmapRangeMax: 50,
          guideFFT: null, guideOCT: null, guideHeatmap: null
        };
        
        this.init();
      }

      init() {
        this.setupEventListeners();
        this.setupCanvases();
        this.updateOctaveRangeText();
        this.updateHeatmapRangeText();
        this.drawInitialFrames();
      }

      getStyle(p) { return getComputedStyle(document.documentElement).getPropertyValue(p).trim(); }

      getDOMElements() {
        const ids = [
          'btnStart', 'btnStop', 'btnHold', 'btnClear', 'btnToggleHeatmap', 'btnHeatmapQuality', 'btnResetDba',
          'fft', 'smoothing', 'avg', 'aWeight', 'ec', 'ns', 'agc',
          'fftPeakText', 'fftHoldText', 'octPeakText', 'octHoldText',
          'fftCanvas', 'octCanvas', 'heatmapCanvas', 'dbMeterCanvas',
          'fftTip', 'octTip', 'heatmapTip',
          'dbRealtimeValue', 'dbAvgValue', 'dbMaxValue',
          'calibrationOffset', 'octTitle', 'octRes',
          'octRangePreset', 'octRangeSlider', 'octRangeText',
          'heatmapRangeSlider', 'heatmapRangePreset', 'heatmapRangeText',
          'rms', 'peak', 'errBox', 'errMsg'
        ];
        const dom = {};
        ids.forEach(id => dom[id] = document.getElementById(id));
        return dom;
      }

      setupEventListeners() {
        this.dom.btnStart.addEventListener('click', () => this.start());
        this.dom.btnStop.addEventListener('click', () => this.stop());
        this.dom.btnClear.addEventListener('click', () => this.clearPeak());
        this.dom.btnResetDba.addEventListener('click', () => this.resetDbaValues());
        
        this.dom.btnHold.addEventListener('click', () => {
          this.state.holdEnabled = !this.state.holdEnabled;
          this.dom.btnHold.setAttribute('aria-pressed', this.state.holdEnabled);
          this.dom.btnHold.textContent = `üìå Hold Peak: ${this.state.holdEnabled ? 'ON' : 'OFF'}`;
        });

        this.dom.btnToggleHeatmap.addEventListener('click', () => {
          this.state.heatmapEnabled = !this.state.heatmapEnabled;
          this.dom.btnToggleHeatmap.setAttribute('aria-pressed', this.state.heatmapEnabled);
          this.dom.btnToggleHeatmap.textContent = `Heatmap: ${this.state.heatmapEnabled ? 'ON' : 'OFF'}`;
          if (!this.state.heatmapEnabled) this.drawHeatmapOverlay();
        });
        
        this.dom.btnHeatmapQuality.addEventListener('click', () => {
          this.state.heatmapIsHD = !this.state.heatmapIsHD;
          this.dom.btnHeatmapQuality.setAttribute('aria-pressed', this.state.heatmapIsHD);
          this.dom.btnHeatmapQuality.textContent = this.state.heatmapIsHD ? 'üî• HD' : '‚ö°Ô∏è SD';
          this.state.heatmapFreqBinMap = this.genHeatmapBins();
          this.state.heatmapData = [];
          if (this.state.heatmapEnabled) {
              this.drawHeatmap(true);
          } else {
              this.drawHeatmapOverlay();
          }
        });

        this.dom.fft.addEventListener('change', () => this.onConfigChange());
        this.dom.smoothing.addEventListener('input', () => {
          if (this.state.analyser) this.state.analyser.smoothingTimeConstant = parseFloat(this.dom.smoothing.value);
        });
        
        this.dom.octRes.addEventListener('change', () => {
            this.state.octN = parseInt(this.dom.octRes.value, 10);
            this.state.bands = this.genBands(this.state.octN);
            this.state.peakOct = new Float32Array(this.state.bands.length);
        });
        
        [this.dom.ec, this.dom.ns, this.dom.agc].forEach(el => el.addEventListener('change', () => {
            if (this.state.running) {
                this.stop();
                setTimeout(() => this.start(), 50);
            }
        }));
        
        this.dom.calibrationOffset.addEventListener('input', () => {
            this.state.calibrationOffset = parseFloat(this.dom.calibrationOffset.value) || 100;
        });

        this.dom.octRangePreset.addEventListener('change', (e) => {
            this.state.octRangeMax = parseInt(e.target.value, 10);
            this.dom.octRangeSlider.value = this.state.octRangeMax;
            this.updateOctaveRangeText();
        });
        this.dom.octRangeSlider.addEventListener('input', (e) => {
            this.state.octRangeMax = parseInt(e.target.value, 10);
            this.updateOctaveRangeText();
        });
        this.dom.heatmapRangePreset.addEventListener('change', (e) => {
            this.state.heatmapRangeMax = parseInt(e.target.value, 10);
            this.dom.heatmapRangeSlider.value = this.state.heatmapRangeMax;
            this.updateHeatmapRangeText();
        });
        this.dom.heatmapRangeSlider.addEventListener('input', (e) => {
            this.state.heatmapRangeMax = parseInt(e.target.value, 10);
            this.updateHeatmapRangeText();
        });
        
        window.addEventListener('resize', () => this.handleResize());
      }
      
      setupCanvases() {
          this.canvases = {
              fft: { canvas: this.dom.fftCanvas, ctx: this.dom.fftCanvas.getContext('2d'), tip: this.dom.fftTip },
              oct: { canvas: this.dom.octCanvas, ctx: this.dom.octCanvas.getContext('2d'), tip: this.dom.octTip },
              heatmap: { canvas: this.dom.heatmapCanvas, ctx: this.dom.heatmapCanvas.getContext('2d'), tip: this.dom.heatmapTip },
              dbMeter: { canvas: this.dom.dbMeterCanvas, ctx: this.dom.dbMeterCanvas.getContext('2d') }
          };
          this.handleResize();
          this.attachPressGuide(this.canvases.fft, 'fft');
          this.attachPressGuide(this.canvases.oct, 'oct');
          this.attachPressGuide(this.canvases.heatmap, 'heatmap');
      }

      handleResize() {
        const dpr = window.devicePixelRatio || 1;
        for (const key in this.canvases) {
            if (!this.canvases[key] || !this.canvases[key].canvas) continue;
            const { canvas, ctx } = this.canvases[key];
            
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            if (ctx) {
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.scale(dpr, dpr);
            }
        }
        this.drawInitialFrames();
        if (this.state.running) {
            this.drawFFT();
            this.drawOctave();
            if (this.state.heatmapEnabled) this.drawHeatmap(true);
        }
      }

      drawInitialFrames() {
        this.drawBackground(this.canvases.fft.ctx);
        this.drawBackground(this.canvases.oct.ctx);
        this.drawHeatmapBackground(this.canvases.heatmap.ctx);
        this.drawHeatmapOverlay();
        this.drawDbMeterBackground();
      }
      
      async start() {
        this.dom.btnStart.disabled = true;
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö getUserMedia API');
          }
          
          const constraints = { audio: { 
            echoCancellation: { ideal: this.dom.ec.checked },
            noiseSuppression: { ideal: this.dom.ns.checked },
            autoGainControl: { ideal: this.dom.agc.checked }
          }};

          let stream;
          try {
              stream = await navigator.mediaDevices.getUserMedia(constraints);
          } catch (e) {
              console.warn("Could not get ideal constraints, trying default.", e);
              stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          }

          const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
          if (audioCtx.state === 'suspended') await audioCtx.resume();

          const analyser = audioCtx.createAnalyser();
          const micSrc = audioCtx.createMediaStreamSource(stream);
          micSrc.connect(analyser);

          this.state = { ...this.state, audioCtx, analyser, micSrc, stream, running: true };
          
          this.onConfigChange();
          this.resetDbaValues();
          this.dom.errBox.style.display = 'none';
          this.dom.btnStop.disabled = false;
          
          this.loop();

        } catch (err) {
          console.error(err);
          this.showError(err.message || String(err));
          this.dom.btnStart.disabled = false;
        }
      }

      stop() {
        if (!this.state.running) return;
        this.state.running = false;
        cancelAnimationFrame(this.state.rafId);

        this.state.stream?.getTracks().forEach(track => track.stop());
        this.state.micSrc?.disconnect();
        this.state.analyser?.disconnect();
        this.state.audioCtx?.close();

        this.state = { ...this.state, audioCtx: null, analyser: null, micSrc: null, stream: null };
        
        this.dom.btnStart.disabled = false;
        this.dom.btnStop.disabled = true;
        this.dom.dbRealtimeValue.textContent = '‚Äî';
        this.updateDbMeter(-Infinity);
      }
      
      onConfigChange() {
          if (!this.state.analyser) return;
          this.state.analyser.fftSize = parseInt(this.dom.fft.value, 10);
          this.state.analyser.smoothingTimeConstant = parseFloat(this.dom.smoothing.value);
          
          this.state.dataArray = new Uint8Array(this.state.analyser.fftSize);
          this.state.freqArray = new Uint8Array(this.state.analyser.frequencyBinCount);
          this.state.peakArray = new Uint8Array(this.state.analyser.frequencyBinCount);
          this.state.avgBuffer = new Float32Array(this.state.analyser.frequencyBinCount);
          
          this.state.sampleRate = this.state.audioCtx.sampleRate;
          this.state.bands = this.genBands(this.state.octN);
          this.state.peakOct = new Float32Array(this.state.bands.length);
          this.state.heatmapFreqBinMap = this.genHeatmapBins();
          this.state.heatmapData = [];
      }

      loop() {
        if (!this.state.running) return;

        this.state.analyser.getByteTimeDomainData(this.state.dataArray);
        this.state.analyser.getByteFrequencyData(this.state.freqArray);
        
        if (this.dom.avg.checked) {
          const a = 0.5;
          for (let i = 0; i < this.state.freqArray.length; i++) {
            this.state.avgBuffer[i] = a * this.state.avgBuffer[i] + (1 - a) * this.state.freqArray[i];
            this.state.freqArray[i] = this.state.avgBuffer[i];
          }
        }
        
        this.drawFFT();
        this.drawOctave();
        this.updateRMS();
        this.updateDba();

        const now = performance.now();
        if (this.state.heatmapEnabled && (now - this.state.lastHeatmapUpdate >= 33)) {
          this.drawHeatmap();
          this.state.lastHeatmapUpdate = now;
        }

        this.state.rafId = requestAnimationFrame(() => this.loop());
      }
      
      clamp01(v) { return Math.min(1, Math.max(0, v)); }
      dbfs(v) { return 20 * Math.log10(v / 255 + 1e-12); }
      fmtHz(f) { return f >= 1000 ? ((f / 1000 >= 10 ? (f / 1000).toFixed(0) : (f / 1000).toFixed(1)) + ' kHz') : (Math.round(f) + ' Hz'); }
      aWeighting(f) { const f2 = f * f; const ra = (12200 ** 2 * f2 ** 2) / ((f2 + 20.6 ** 2) * (f2 + 12200 ** 2) * Math.sqrt((f2 + 107.7 ** 2) * (f2 + 737.9 ** 2))); return 20 * Math.log10(ra) + 2.0; }
      fmax() { return Math.min(this.state.sampleRate / 2, 20000); }
      mapLogX(f, w) { const fm = this.fmax(); const fmin = 20; const t = (Math.log10(Math.max(f, fmin)) - Math.log10(fmin)) / (Math.log10(fm) - Math.log10(fmin)); return this.PAD.L + t * (w - this.PAD.L - this.PAD.R); }
      xToFreq(x, w) { const fm = this.fmax(); const fmin = 20; const plotW = w - this.PAD.L - this.PAD.R; const t = this.clamp01((x - this.PAD.L) / plotW); const lf = Math.log10(fmin) + t * (Math.log10(fm) - Math.log10(fmin)); return Math.pow(10, lf); }
      mapDbToY(db, h) { const norm = this.clamp01((db + 100) / 100); const plotH = h - this.PAD.T - this.PAD.B; return this.PAD.T + (1 - norm) * plotH; }
      mapLinearToYOct(v, h) { const norm = this.clamp01(v / Math.max(1, this.state.octRangeMax)); const plotH = h - this.PAD.T - this.PAD.B; return this.PAD.T + (1 - norm) * plotH; }
      mapDbToColorHeatmap(db) {
          const maxDb = 0; const minDb = maxDb - this.state.heatmapRangeMax;
          const t = this.clamp01((db - minDb) / (maxDb - minDb));
          if (t < 0.25) return this.colors.heatmap[0]; if (t < 0.5) return this.colors.heatmap[1];
          if (t < 0.75) return this.colors.heatmap[2]; if (t < 0.9) return this.colors.heatmap[3];
          return this.colors.heatmap[4];
      }

      genBands(n) {
        const r = Math.pow(2, 1 / n), fm = this.fmax(), fmin = 20;
        const kmin = Math.ceil(Math.log(fmin / 1000) / Math.log(r));
        const kmax = Math.floor(Math.log(fm / 1000) / Math.log(r));
        const edgeHalf = Math.pow(2, 1 / (2 * n));
        const arr = [];
        for (let k = kmin; k <= kmax; k++) {
          const fc = 1000 * Math.pow(r, k), fl = fc / edgeHalf, fh = fc * edgeHalf;
          if (fh < fmin || fl > fm) continue;
          arr.push({ fc, fl: Math.max(fl, fmin), fh: Math.min(fh, fm) });
        }
        if (arr.length) this.dom.octTitle.textContent = `RTA ‡πÅ‡∏ö‡∏ö 1/${n} Octave (Linear Axis)`;
        return arr;
      }

      genHeatmapBins() {
        if (!this.state.analyser) return null;
        const numBins = this.state.heatmapIsHD ? this.HEATMAP_BINS_HD : this.HEATMAP_BINS_SD;
        const fm = this.fmax(), fpb = this.state.sampleRate / this.state.analyser.fftSize, fmin = 20;
        const logFmin = Math.log10(fmin), logFmax = Math.log10(fm);
        const bins = [];
        for (let i = 0; i < numBins; i++) {
          const logFs = logFmin + (i / numBins) * (logFmax - logFmin);
          const logFe = logFmin + ((i + 1) / numBins) * (logFmax - logFmin);
          const fStart = Math.pow(10, logFs), fEnd = Math.pow(10, logFe);
          const binStart = Math.max(0, Math.floor(fStart / fpb));
          const binEnd = Math.min(this.state.analyser.frequencyBinCount - 1, Math.ceil(fEnd / fpb));
          bins.push({ binStart, binEnd, fStart, fEnd });
        }
        return bins;
      }
      
      drawBackground(ctx) {
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          ctx.clearRect(0, 0, plotW, plotH);
          const plotAreaH = plotH - this.PAD.T - this.PAD.B;
          ctx.strokeStyle = this.colors.gridH;
          for (let i = 0; i < 6; i++) { const y = this.PAD.T + (i / 5) * plotAreaH; ctx.beginPath(); ctx.moveTo(this.PAD.L, y); ctx.lineTo(plotW - this.PAD.R, y); ctx.stroke(); }
          ctx.strokeStyle = this.colors.gridV;
          const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
          ticks.forEach(t => { const x = this.mapLogX(t, plotW); ctx.beginPath(); ctx.moveTo(x, this.PAD.T); ctx.lineTo(x, this.PAD.T + plotAreaH); ctx.stroke(); });
          ctx.strokeStyle = this.colors.frame; ctx.strokeRect(this.PAD.L, this.PAD.T, plotW - this.PAD.L - this.PAD.R, plotAreaH);
          ctx.fillStyle = this.colors.label; ctx.font = '12px system-ui'; ctx.textBaseline = 'alphabetic';
          [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => { const x = this.mapLogX(t, plotW); ctx.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, plotH - this.LABEL_Y); });
      }
      
      drawFFT() {
          const { ctx } = this.canvases.fft;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          this.drawBackground(ctx);
          if (!this.state.freqArray) return;
          const N = this.state.freqArray.length, fpb = this.state.sampleRate / (2 * N);
          if (this.state.holdEnabled) {
              for (let i = 0; i < N; i++) this.state.peakArray[i] = Math.max(this.state.peakArray[i], this.state.freqArray[i]);
          }
          ctx.beginPath(); let started = false;
          for (let i = 1; i < N; i++) {
              const f = i * fpb; if (f < 20 || f > this.fmax()) continue;
              const x = this.mapLogX(f, plotW), y = this.mapDbToY(this.dbfs(this.state.freqArray[i]), plotH);
              if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
          }
          ctx.strokeStyle = this.colors.fft; ctx.lineWidth = 2; ctx.stroke();
          ctx.beginPath(); started = false;
          for (let i = 1; i < N; i++) {
              const f = i * fpb; if (f < 20 || f > this.fmax()) continue;
              const x = this.mapLogX(f, plotW), y = this.mapDbToY(this.dbfs(this.state.peakArray[i] || 0), plotH);
              if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
          }
          ctx.save(); ctx.globalAlpha = .35; ctx.strokeStyle = this.colors.peak; ctx.lineWidth = 1.25; ctx.stroke(); ctx.restore();
          let peakBin = 0, peakVal = -Infinity; for (let i = 0; i < N; i++) if (this.state.freqArray[i] > peakVal) { peakVal = this.state.freqArray[i]; peakBin = i; }
          const peakFreqNow = peakBin * fpb; const peakDbNow = this.dbfs(peakVal || 0);
          this.dom.peak.textContent = this.fmtHz(peakFreqNow);
          this.dom.fftPeakText.textContent = `Peak: ${this.fmtHz(peakFreqNow)} ‚Ä¢ ${peakDbNow.toFixed(1)} dBFS`;
          let holdBin = 0, holdVal = 0; for (let i = 0; i < N; i++) if (this.state.peakArray[i] > holdVal) { holdVal = this.state.peakArray[i]; holdBin = i; }
          if (holdVal > 0) {
              this.dom.fftHoldText.style.display = '';
              this.dom.fftHoldText.textContent = `Hold: ${this.fmtHz(holdBin * fpb)} ‚Ä¢ ${this.dbfs(holdVal).toFixed(1)} dBFS`;
              this.drawPeakLine(ctx, this.mapLogX(holdBin * fpb, plotW), plotH, this.colors.hold, true);
          } else {
              this.dom.fftHoldText.style.display = 'none';
          }
          this.drawPeakLine(ctx, this.mapLogX(peakFreqNow, plotW), plotH, 'rgba(100,149,237,.6)');
          if (this.state.guideFFT) this.drawGuide(ctx, this.state.guideFFT.xPx, plotH);
      }

      drawOctave() {
          const { ctx } = this.canvases.oct;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          this.drawBackground(ctx);
          if (!this.state.freqArray || !this.state.bands.length) return;
          const N = this.state.freqArray.length, fpb = this.state.sampleRate / (2 * N);
          const vals = this.state.bands.map(b => {
              const s = Math.max(0, Math.floor(b.fl / fpb)), e = Math.min(N - 1, Math.ceil(b.fh / fpb));
              let sum = 0, cnt = 0;
              for (let i = s; i <= e; i++) { sum += this.state.freqArray[i]; cnt++; }
              let v = cnt ? (sum / cnt) : 0;
              if (this.dom.aWeight.checked) v *= Math.pow(10, this.aWeighting(b.fc) / 20);
              return v;
          });
          if (this.state.holdEnabled) {
              for (let i = 0; i < vals.length; i++) this.state.peakOct[i] = Math.max(this.state.peakOct[i], vals[i]);
          }
          ctx.fillStyle = this.colors.bar;
          for (let i = 0; i < vals.length; i++) {
              const b = this.state.bands[i];
              const xL = this.mapLogX(b.fl, plotW), xR = this.mapLogX(b.fh, plotW);
              const barW = Math.max(2, xR - xL - 2);
              const y = this.mapLinearToYOct(vals[i], plotH);
              const barH = (plotH - this.PAD.B - y);
              ctx.fillRect(xL + 1, y, barW, Math.max(1, barH));
          }
          ctx.beginPath();
          for (let i = 0; i < vals.length; i++) {
              const cx = this.mapLogX(this.state.bands[i].fc, plotW);
              const y = this.mapLinearToYOct(this.state.peakOct[i] || 0, plotH);
              if (i === 0) ctx.moveTo(cx, y); else ctx.lineTo(cx, y);
          }
          ctx.save(); ctx.globalAlpha = .45; ctx.strokeStyle = this.colors.hold; ctx.lineWidth = 1.5; ctx.stroke(); ctx.restore();
          let idxNow = 0, vNow = -1; for (let i = 0; i < vals.length; i++) if (vals[i] > vNow) { vNow = vals[i]; idxNow = i; }
          let idxHold = 0, vHold = 0; for (let i = 0; i < this.state.peakOct.length; i++) if (this.state.peakOct[i] > vHold) { vHold = this.state.peakOct[i]; idxHold = i; }
          this.dom.octPeakText.textContent = `Peak: ${this.fmtHz(this.state.bands[idxNow].fc)} ‚Ä¢ ${vNow.toFixed(1)} / ${this.state.octRangeMax}`;
          if (vHold > 0) {
              this.dom.octHoldText.style.display = '';
              this.dom.octHoldText.textContent = `Hold: ${this.fmtHz(this.state.bands[idxHold].fc)} ‚Ä¢ ${vHold.toFixed(1)} / ${this.state.octRangeMax}`;
              this.drawPeakLine(ctx, this.mapLogX(this.state.bands[idxHold].fc, plotW), plotH, this.colors.hold, true);
          } else {
              this.dom.octHoldText.style.display = 'none';
          }
          this.drawPeakLine(ctx, this.mapLogX(this.state.bands[idxNow].fc, plotW), plotH, 'rgba(100,149,237,.6)');
          if (this.state.guideOCT) this.drawGuide(ctx, this.state.guideOCT.xPx, plotH);
      }

      drawHeatmap(forceRedraw = false) {
          const mainCtx = this.canvases.heatmap.ctx;
          const { width: w, height: h } = mainCtx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          const plotAreaH = plotH - this.PAD.B;

          if (!this.state.freqArray || !this.state.heatmapFreqBinMap) return;

          const frame = this.state.heatmapFreqBinMap.map(bin => {
              let sum = 0, cnt = 0;
              for (let j = bin.binStart; j <= bin.binEnd; j++) { sum += this.state.freqArray[j]; cnt++; }
              const avgDb = cnt > 0 ? this.dbfs(sum / cnt) : -100;
              return { db: avgDb };
          });
          
          this.state.heatmapData.unshift(frame);
          if (this.state.heatmapData.length > this.HEATMAP_TIME_SLICES) {
              this.state.heatmapData.pop();
          }
          
          this.drawHeatmapBackground(mainCtx);
          const timeScale = plotAreaH / this.HEATMAP_TIME_SLICES;
          for (let i = 0; i < this.state.heatmapData.length; i++) {
              const y = i * timeScale;
              const row = this.state.heatmapData[i];
              for (let j = 0; j < row.length; j++) {
                  const { fStart, fEnd } = this.state.heatmapFreqBinMap[j];
                  const xL = this.mapLogX(fStart, plotW), xR = this.mapLogX(fEnd, plotW);
                  mainCtx.fillStyle = this.mapDbToColorHeatmap(row[j].db);
                  mainCtx.fillRect(xL, y, Math.max(1, xR - xL), timeScale);
              }
          }
          
          this.drawHeatmapGrid(mainCtx);
          if (this.state.guideHeatmap) this.drawHeatmapGuide(mainCtx, this.state.guideHeatmap.xPx, plotH);
      }
      
      drawHeatmapBackground(ctx) {
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        ctx.clearRect(0, 0, plotW, plotH);
      }

      drawHeatmapGrid(ctx) {
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        const plotAreaH = plotH - this.PAD.B;
        ctx.strokeStyle = this.colors.frame;
        ctx.strokeRect(this.PAD.L, 0, plotW - this.PAD.L - this.PAD.R, plotAreaH);
        ctx.strokeStyle = this.colors.gridV;
        const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
        ticks.forEach(t => { const x = this.mapLogX(t, plotW); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, plotAreaH); ctx.stroke(); });
        ctx.fillStyle = this.colors.label; ctx.font = '12px system-ui'; ctx.textBaseline = 'alphabetic';
        [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => { const x = this.mapLogX(t, plotW); ctx.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, plotH - this.LABEL_Y); });
      }

      drawHeatmapOverlay() {
          const { ctx } = this.canvases.heatmap;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          this.drawHeatmapBackground(ctx);
          ctx.fillStyle = 'rgba(255,255,255,.4)';
          ctx.font = '24px system-ui';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Heatmap OFF', plotW / 2, (plotH - this.PAD.B) / 2);
      }
      
      drawPeakLine(ctx, x, h, color, dashed = false) { const y0 = this.PAD.T, y1 = h - this.PAD.B; ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 1; if (dashed) ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y1); ctx.stroke(); ctx.restore(); }
      drawGuide(ctx, x, h) { ctx.save(); ctx.strokeStyle = 'rgba(100,149,237,.75)'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(x, this.PAD.T); ctx.lineTo(x, h - this.PAD.B); ctx.stroke(); ctx.restore(); }
      drawHeatmapGuide(ctx, x, h) { ctx.save(); ctx.strokeStyle = 'rgba(100,149,237,.75)'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h - this.PAD.B); ctx.stroke(); ctx.restore(); }
      
      updateRMS() { if (!this.state.dataArray) return; let sum = 0; for (let i = 0; i < this.state.dataArray.length; i++) { const v = (this.state.dataArray[i] - 128) / 128; sum += v * v; } const rms = Math.sqrt(sum / this.state.dataArray.length); this.dom.rms.textContent = (20 * Math.log10(rms + 1e-12)).toFixed(1) + ' dBFS'; }
      calculateDba() { if (!this.state.freqArray || !this.state.analyser) return -Infinity; const N = this.state.freqArray.length, fpb = this.state.sampleRate / this.state.analyser.fftSize; let sum = 0; for (let i = 0; i < N; i++) { const f = i * fpb; const aw = Math.pow(10, this.aWeighting(f) / 20); const v = this.state.freqArray[i] * aw; sum += v * v; } const rms = Math.sqrt(sum / N); const dbfsValue = 20 * Math.log10(rms / 255 + 1e-12); return dbfsValue + this.state.calibrationOffset; }
      drawDbMeterBackground() { const { ctx } = this.canvases.dbMeter; const { width: w, height: h } = ctx.canvas; ctx.clearRect(0, 0, w, h); }
      
      updateDbMeter(db) {
          const { ctx } = this.canvases.dbMeter;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          const dbMin = 0, dbMax = 140;
          const fillW = plotW * this.clamp01((db - dbMin) / (dbMax - dbMin));
          const g = ctx.createLinearGradient(0, 0, plotW, 0);
          
          // UPDATED: New gradient stops for a more natural progression
          g.addColorStop(0, this.colors.dbMeter.green);      // Start green
          g.addColorStop(0.357, this.colors.dbMeter.green);  // End green at 50dB (50/140)
          g.addColorStop(0.571, this.colors.dbMeter.yellow); // Transition to yellow by 80dB (80/140)
          g.addColorStop(0.714, this.colors.dbMeter.orange); // Transition to orange by 100dB (100/140)
          g.addColorStop(0.785, this.colors.dbMeter.red);   // Transition to red by 110dB (110/140)
          g.addColorStop(1, this.colors.dbMeter.red);        // End with red
          
          this.drawDbMeterBackground();
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, fillW, plotH);
      }

      updateDba() {
          const dbAraw = this.calculateDba(), dbAdisp = Math.max(0, dbAraw);
          this.updateDbMeter(dbAdisp);
          if (this.state.dbaValues.length === 0) {
              if (dbAdisp > 0) {
                  this.state.dbaValues.push(dbAdisp);
                  this.dom.dbRealtimeValue.textContent = `${dbAdisp.toFixed(1)} dB`;
                  this.dom.dbAvgValue.textContent = this.dom.dbMaxValue.textContent = `${dbAdisp.toFixed(1)} dB`;
                  this.state.maxDba = dbAdisp;
              } else {
                  this.dom.dbRealtimeValue.textContent = '‚Äî'; this.dom.dbAvgValue.textContent = '‚Äî'; this.dom.dbMaxValue.textContent = '‚Äî';
              }
          } else {
              this.dom.dbRealtimeValue.textContent = `${dbAdisp.toFixed(1)} dB`;
              if (dbAdisp > this.state.maxDba) { this.state.maxDba = dbAdisp; this.dom.dbMaxValue.textContent = `${this.state.maxDba.toFixed(1)} dB`; }
              if (dbAdisp > 0) { this.state.dbaValues.push(dbAdisp); if (this.state.dbaValues.length > 100) this.state.dbaValues.shift(); }
              const avg = this.state.dbaValues.reduce((a, b) => a + b, 0) / this.state.dbaValues.length;
              this.dom.dbAvgValue.textContent = `${avg.toFixed(1)} dB`;
          }
      }
      resetDbaValues() { this.state.maxDba = -Infinity; this.state.dbaValues = []; this.dom.dbRealtimeValue.textContent = '‚Äî'; this.dom.dbAvgValue.textContent = '‚Äî'; this.dom.dbMaxValue.textContent = '‚Äî'; }
      clearPeak() { this.state.peakArray.fill(0); this.state.peakOct.fill(0); }
      updateOctaveRangeText() { this.dom.octRangeText.textContent = `0‚Äì${this.state.octRangeMax}`; }
      updateHeatmapRangeText() { this.dom.heatmapRangeText.textContent = `0 to -${this.state.heatmapRangeMax} dBFS`; }
      
      showError(msg) { this.dom.errBox.style.display = 'block'; this.dom.errMsg.textContent = msg; }
      
      attachPressGuide({ canvas, tip }, which) {
        let pressed = false;
        const getX = (e) => { const r = canvas.getBoundingClientRect(); const xCss = (e.touches ? e.touches[0].clientX : e.clientX) - r.left; return Math.max(this.PAD.L, Math.min(r.width - this.PAD.R, xCss)); };
        const update = (xPx) => {
            const freq = this.xToFreq(xPx, canvas.getBoundingClientRect().width);
            const plot = canvas.parentElement.getBoundingClientRect();
            tip.style.display = 'block'; tip.textContent = this.fmtHz(freq);
            tip.style.left = xPx + 'px'; tip.style.top = '8px';
            const guideState = { xPx, freq };
            if (which === 'fft') this.state.guideFFT = guideState;
            else if (which === 'oct') this.state.guideOCT = guideState;
            else if (which === 'heatmap') {
                this.state.guideHeatmap = guideState;
            }
        };
        const clear = () => {
            pressed = false; tip.style.display = 'none';
            if (which === 'fft') this.state.guideFFT = null;
            else if (which === 'oct') this.state.guideOCT = null;
            else if (which === 'heatmap') {
                this.state.guideHeatmap = null;
            }
        };
        const onDown = (e) => { pressed = true; e.preventDefault(); update(getX(e)); };
        const onMove = (e) => { if (!pressed) return; e.preventDefault(); update(getX(e)); };
        const onUp = () => clear();
        canvas.addEventListener('mousedown', onDown); canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp); canvas.addEventListener('mouseleave', onUp);
        canvas.addEventListener('touchstart', onDown, { passive: false });
        canvas.addEventListener('touchmove', onMove, { passive: false });
        canvas.addEventListener('touchend', onUp);
      }
    }

    new RTAnalyzer();

  })();
  </script>
</body>
</html>
