<!DOCTYPE html>
<html lang="th" data-theme="dark-matter">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#1a202c" />
  <meta name="theme-color" content="#1a202c" media="(prefers-color-scheme: dark)" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Mobile RTA (Pro Refactor with Off-screen Canvas)</title>

  <style>
    /* --- Theme: Dark Matter (Default) --- */
    :root, [data-theme="dark-matter"] {
      --bg1:#1a202c; --bg2:#1a202c; --card:#2d3748; --text:#cbd5e1; --muted:#718096;
      --gridH:rgba(255,255,255,.08); --gridV:rgba(255,255,255,.04);
      --frame:rgba(255,255,255,.1); --label:rgba(255,255,255,.85);
      --fft:#68d391; --peak:#b794f4; --hold:#f6ad55; --bar:#68d391;
      --heatmap-color-1:#1a202c; --heatmap-color-2:#4a5568; --heatmap-color-3:#68d391;
      --heatmap-color-4:#f6ad55; --heatmap-color-5:#e53e3e;
      --dba-meter-bg-green: #48bb78;
      --dba-meter-bg-yellow: #f6ad55;
      --dba-meter-bg-orange: #ed8936;
      --dba-meter-bg-red: #e53e3e;
      --accent-color: #2DD4BF; /* Teal */
    }

    /* --- Theme: Studio Blue --- */
    [data-theme="studio-blue"] {
      --bg1:#0F172A; --bg2:#1E293B; --card:#1E293B; --text:#E2E8F0; --muted:#64748B;
      --gridH:rgba(255,255,255,.1); --gridV:rgba(255,255,255,.05);
      --frame:rgba(255,255,255,.12); --label:rgba(255,255,255,.9);
      --fft:#22D3EE; --peak:#A5B4FC; --hold:#F472B6; --bar:#22D3EE;
      --heatmap-color-1:#0F172A; --heatmap-color-2:#334155; --heatmap-color-3:#0EA5E9;
      --heatmap-color-4:#A78BFA; --heatmap-color-5:#F472B6;
      --dba-meter-bg-green: #22D3EE;
      --dba-meter-bg-yellow: #A78BFA;
      --dba-meter-bg-orange: #EC4899;
      --dba-meter-bg-red: #F43F5E;
      --accent-color: #60A5FA; /* Slate Blue */
    }

    /* --- Theme: Vintage Amber --- */
    [data-theme="vintage-amber"] {
      --bg1:#292524; --bg2:#1c1917; --card:#44403C; --text:#D6D3D1; --muted:#A8A29E;
      --gridH:rgba(255,250,235,.1); --gridV:rgba(255,250,235,.05);
      --frame:rgba(255,250,235,.12); --label:rgba(255,250,235,.9);
      --fft:#F59E0B; --peak:#FDE68A; --hold:#FDBA74; --bar:#F59E0B;
      --heatmap-color-1:#292524; --heatmap-color-2:#78716C; --heatmap-color-3:#F59E0B;
      --heatmap-color-4:#FBBF24; --heatmap-color-5:#EF4444;
      --dba-meter-bg-green: #F59E0B;
      --dba-meter-bg-yellow: #FACC15;
      --dba-meter-bg-orange: #FB923C;
      --dba-meter-bg-red: #EF4444;
      --accent-color: #D97706; /* Burnt Orange */
    }

    :root{ color-scheme:dark }
    html{ background:var(--bg1) }
    body{
      margin:0; height:100%;
      background:radial-gradient(1200px 600px at 70% -10%, var(--card) 10%, var(--bg1) 60%, var(--bg2) 100%);
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif;
      -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; overscroll-behavior:contain;
      transition: background .3s, color .3s;
    }
    /* Safe Area */
    body::before,body::after{content:"";position:fixed;left:0;right:0;z-index:9999;background:var(--bg1);pointer-events:none}
    body::before{top:0;height:env(safe-area-inset-top)} body::after{bottom:0;height:env(safe-area-inset-bottom)}
    @supports(padding: env(safe-area-inset-left)){
      html::before,html::after{content:"";position:fixed;top:0;bottom:0;background:var(--bg1);z-index:9998;pointer-events:none}
      html::before{left:0;width:env(safe-area-inset-left)} html::after{right:0;width:env(safe-area-inset-right)}
    }

    .wrap{display:flex;flex-direction:column;gap:12px;max-width:920px;margin:0 auto;
      padding-left:calc(12px + env(safe-area-inset-left));
      padding-right:calc(12px + env(safe-area-inset-right));
      padding-top:calc(12px + env(safe-area-inset-top));
      padding-bottom:calc(12px + env(safe-area-inset-bottom));
    }
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.1);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px; transition: background-color .3s, border-color .3s;}
    button,select,input[type=range],input[type=number]{-webkit-tap-highlight-color:transparent}
    button{background:var(--accent-color);border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:background-color .2s, opacity .2s;}
    button:disabled{opacity:.5;cursor:not-allowed;}
    button.secondary{background:rgba(0,0,0,.2);} button.ghost{background:rgba(0,0,0,.2);}
    label{font-size:12px;color:var(--muted)}
    .meters{display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:100%;height:320px;background:var(--bg1);border-radius:12px;touch-action:none; display: block; transition: background-color .3s;}

    #dbMeterContainer{position:relative;background:rgba(255,255,255,.1);border-radius:999px;overflow:hidden}
    #dbMeterCanvas{height:20px;background:transparent;border-radius:999px}
    .dbLabel{position:absolute;font-size:10px;color:var(--muted);bottom:4px}

    .hint{font-size:12px;color:var(--muted)}
    .kv{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .kv div{background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:8px}
    .kv b{display:block;color:var(--text);font-size:12px;margin-bottom:4px}
    .badges{display:flex;justify-content:flex-end;gap:6px;}
    .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px;color:#e5e7eb;white-space:nowrap}
    .tip{position:absolute;padding:4px 6px;font-size:12px;color:#e5e7eb;background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.12);border-radius:8px;transform:translate(-50%,-100%);pointer-events:none;white-space:nowrap;z-index:10}
    .plot{position:relative; height: 320px; margin-top: 8px;}

    .dba-values-row{display:flex;justify-content:space-between;gap:8px}
    .dba-values-row .kv-item{flex:1;background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:8px;text-align:center}
    .dba-values-row .kv-item b{display:block;color:var(--text);font-size:12px;margin-bottom:4px}
    
    input[type="range"], input[type="checkbox"] {
      accent-color: var(--accent-color);
    }

    details.dev summary { cursor: pointer; }
    .status { display:inline-block; padding:2px 6px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.3); }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Error banner -->
    <div id="errBox" class="card" style="display:none;border-color:#e53e3e;background:#1c2430">
      <b style="color:#fca5a5">‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</b>
      <div id="errMsg" class="hint" style="color:#fca5a5">‚Äî</div>
      <div class="row" style="margin-top:8px">
        <button id="btnStartDemo" class="secondary">üß™ ‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏î‡πÇ‡∏°‡πà (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡∏Ñ‡πå)</button>
        <span class="hint">‡∏ñ‡πâ‡∏≤‡∏ö‡∏£‡∏≤‡∏ß‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÑ‡∏°‡∏Ñ‡πå ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ HTTPS ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏î‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏£‡∏π‡∏õ‡∏Å‡∏∏‡∏ç‡πÅ‡∏à‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï</span>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center;">
        <h2 style="margin:0 0 4px 0">my RTAs (v. 1.0) 14/8/68</h2>
        <div class="row">
          <button id="btnStart">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î</button>
          <button id="btnStop" class="secondary" disabled>‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
          <button id="btnHold" class="ghost" aria-pressed="true">üìå Hold Peak: ON</button>
          <button id="btnClear" class="secondary">‚ôªÔ∏è Clear Peak</button>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <label> Smoothing <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75"></label>
        <label> Averaging <input id="avg" type="checkbox" checked></label>
        <label> A-weighting (‡πÄ‡∏î‡πÇ‡∏°‡πà) <input id="aWeight" type="checkbox"></label>
        <span class="status" id="secureStatus">Secure: ‚Äî</span>
        <span class="status" id="permStatus">Mic Perm: ‚Äî</span>
      </div>

      <div class="row" style="justify-content:space-between;">
        <div class="row">
            <label>‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏õ‡∏¥‡∏î DSP ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö:</label>
            <div class="row">
              <label>echoCancellation <input id="ec" type="checkbox" checked></label>
              <label>noiseSuppression <input id="ns" type="checkbox" checked></label>
              <label>autoGainControl <input id="agc" type="checkbox" checked></label>
            </div>
        </div>
        <label>Theme
            <select id="themeSelector">
              <option value="dark-matter">Dark Matter</option>
              <option value="studio-blue">Studio Blue</option>
              <option value="vintage-amber">Vintage Amber</option>
            </select>
        </label>
      </div>
    </div>

    <div class="meters">
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <div class="row">
            <b>RTA FFT - Log</b>
          </div>
          <div class="badges" style="margin-left: auto; margin-right: auto;">
            <span class="badge" id="fftPeakText">Peak: ‚Äî</span>
            <span class="badge" id="fftHoldText" style="display:none;">Hold: ‚Äî</span>
          </div>
          <div class="row">
            <label>FFT Size
              <input id="fftRangeSlider" type="range" min="0" max="3" step="1" value="1">
              <select id="fftSizePreset">
                <option value="2048">2048</option>
                <option value="4096" selected>4096</option>
                <option value="8192">8192</option>
                <option value="16384">16384</option>
              </select>
            </label>
          </div>
        </div>
        <div class="plot">
          <canvas id="fftCanvas"></canvas>
          <div id="fftTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <div class="row">
            <b>RTA</b>
            <select id="octRes">
              <option value="3">1/3</option>
              <option value="6">1/6</option>
              <option value="12" selected>1/12</option>
            </select>
            <b id="octTitle">Octave</b>
          </div>
          <div class="badges" style="margin-left: auto; margin-right: auto;">
            <span class="badge" id="octPeakText">Peak: ‚Äî</span>
            <span class="badge" id="octHoldText" style="display:none;">Hold: ‚Äî</span>
          </div>
          <div class="row">
            <label style="display:flex;align-items:center;gap:6px">Range
              <input id="octRangeSlider" type="range" min="64" max="1023" step="1" value="255" aria-label="Octave bar range">
              <select id="octRangePreset">
                <option value="127">127</option>
                <option value="255" selected>256</option>
                <option value="511">512</option>
              </select>
            </label>
            <span class="hint" id="octRangeText">0‚Äì255</span>
          </div>
        </div>
        <div class="plot">
          <canvas id="octCanvas"></canvas>
          <div id="octTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <div class="card" id="heatmapCard">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <div class="row">
            <b id="heatmapTitle">Spectrogram</b>
            <button id="btnToggleHeatmap" class="ghost" aria-pressed="false">OFF</button>
            <button id="btnHeatmapQuality" class="ghost" aria-pressed="true">HD</button>
          </div>
          <div class="badges" style="margin-left: auto; margin-right: auto;">
            <span class="badge" id="heatmapAthText">ATH: ‚Äî</span>
            <button id="btnClearAth" class="ghost" style="font-size:12px;padding:4px 8px; margin-left:4px;">Clear</button>
          </div>
          <div class="row">
            <label style="display:flex;align-items:center;gap:6px">Range
              <input id="heatmapRangeSlider" type="range" min="5" max="100" step="5" value="50" aria-label="Heatmap range">
              <select id="heatmapRangePreset">
                <option value="5">5</option> <option value="10">10</option> <option value="20">20</option> <option value="40">40</option>
                <option value="50" selected>50</option> <option value="60">60</option> <option value="80">80</option> <option value="100">100</option>
              </select>
            </label>
            <span class="hint" id="heatmapRangeText">-50</span>
          </div>
        </div>
        <div class="plot">
          <canvas id="heatmapCanvas"></canvas>
          <div id="heatmapTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏á‡∏£‡∏ß‡∏° dB</b>
          <button id="btnResetDba" class="secondary" style="font-size:12px;padding:6px 10px;">‚ôªÔ∏è Reset AVG/MAX</button>
        </div>
        <div id="dbMeterContainer">
          <canvas id="dbMeterCanvas"></canvas>
          <span class="dbLabel" style="left:0%">0</span>
          <span class="dbLabel" style="left:28.57%">40</span>
          <span class="dbLabel" style="left:57.14%">80</span>
          <span class="dbLabel" style="left:85.71%">120</span>
          <span class="dbLabel" style="right:0">140</span>
        </div>
        <div class="dba-values-row" style="margin-top:12px;">
          <div class="kv-item"><b>Realtime (dB)</b><span id="dbRealtimeValue">‚Äî</span></div>
          <div class="kv-item"><b>AVG (dB)</b><span id="dbAvgValue">‚Äî</span></div>
          <div class="kv-item"><b>MAX (dB)</b><span id="dbMaxValue">‚Äî</span></div>
        </div>
      </div>
    </div>

    <div class="card kv">
      <div><b>‡∏£‡∏∞‡∏î‡∏±‡∏ö RMS (‡∏î‡∏¥‡∏ö dBFS)</b><span id="rms">‚Äî</span></div>
      <div><b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏û‡∏µ‡∏Ñ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì</b><span id="peak">‚Äî</span></div>
    </div>

    <div class="card row" style="justify-content:space-between;align-items:center;margin-top:0">
      <div class="hint">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏ü‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á dBFS ‡πÄ‡∏õ‡πá‡∏ô dBA (‡∏à‡∏≤‡∏Å‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)</div>
      <label>Calibration Offset (dB) <input id="calibrationOffset" type="number" min="0" step="0.1" value="100" style="width:60px;padding:4px;border-radius:6px;border:1px solid #4a5568;background:#2d3748;color:white;"></label>
    </div>

    <div class="card hint">‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î: ‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡∏°‡∏µ DSP/AGC ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÑ‡∏°‡πà‡πÅ‡∏ü‡∏•‡∏ï ‡πÉ‡∏ä‡πâ‡∏î‡∏π‡πÅ‡∏ô‡∏ß EQ ‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏°‡∏≤‡∏ï‡∏£‡∏ß‡∏±‡∏î SPL ‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û</div>

    <details class="card dev">
      <summary>Dev Diagnostics / Tests</summary>
      <div id="testResults" class="hint">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏±‡∏ô‡πÄ‡∏ó‡∏™‡∏ï‡πå‚Ä¶</div>
    </details>
  </div>

  <script>
  (() => {
    class RTAnalyzer {
      constructor() {
        this.PAD = { L: 40, R: 10, T: 10, B: 32 };
        this.LABEL_Y = 10;
        this.HEATMAP_TIME_SLICES = 200;
        this.HEATMAP_BINS_HD = 300;
        this.HEATMAP_BINS_SD = 60;
        this.FFT_SIZES = [2048, 4096, 8192, 16384];

        this.dom = this.getDOMElements();
        this.colors = {};
        
        this.state = {
          audioCtx: null, analyser: null, micSrc: null, stream: null, rafId: null,
          dataArray: null, freqArray: null,
          sampleRate: 48000,
          running: false,
          holdEnabled: true,
          heatmapEnabled: false,
          heatmapIsHD: true,
          peakArray: null, peakOct: null, 
          athHeatmap: { value: -Infinity, bin: 0 },
          avgBuffer: null,
          octN: 12, bands: [],
          heatmapData: [], heatmapFreqBinMap: null,
          lastHeatmapUpdate: 0,
          calibrationOffset: 100,
          maxDba: -Infinity, dbaValues: [],
          octRangeMax: 255, heatmapRangeMax: 50,
          guideFFT: null, guideOCT: null, guideHeatmap: null,
          demo: { enabled: false, oscillators: [], noise: null, gain: null }
        };
        
        this.init();
      }

      init() {
        this.applyTheme('dark-matter');
        this.setupEventListeners();
        this.setupCanvases();
        this.updateOctaveRangeText();
        this.updateHeatmapRangeText();
        this.drawInitialFrames();
        this.preflight();
        this.runTests();
      }

      preflight() {
        const secure = window.isSecureContext || /^localhost$|^127\.[0-9.]+$/.test(location.hostname);
        this.dom.secureStatus.textContent = `Secure: ${secure ? 'yes' : 'no'}`;
        this.dom.secureStatus.style.background = secure ? 'rgba(16,185,129,.2)' : 'rgba(245,158,11,.2)';
        if (!navigator.mediaDevices?.getUserMedia) {
          this.showError('‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö getUserMedia ‚Äî ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ Chrome/Edge/Firefox ‡∏´‡∏£‡∏∑‡∏≠ Safari ‡∏£‡∏∏‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà');
        }
        if (navigator.permissions && navigator.permissions.query) {
          try {
            navigator.permissions.query({ name: 'microphone' }).then((p) => {
              this.dom.permStatus.textContent = `Mic Perm: ${p.state}`;
              this.dom.permStatus.style.background = p.state === 'granted' ? 'rgba(16,185,129,.2)' : (p.state === 'prompt' ? 'rgba(59,130,246,.2)' : 'rgba(239,68,68,.2)');
            }).catch(()=>{});
          } catch(_){}
        }
      }

      runTests() {
        try {
          const ok = !!(window.AudioContext || window.webkitAudioContext);
          this.dom.testResults.textContent = ok ? 'OK: WebAudio ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' : '‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ‡πÑ‡∏°‡πà‡∏°‡∏µ WebAudio';
        } catch (e) {
          this.dom.testResults.textContent = '‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + (e.message || e);
        }
      }

      getStyle(p) { return getComputedStyle(document.documentElement).getPropertyValue(p).trim(); }

      getDOMElements() {
        const ids = [
          'btnStart', 'btnStop', 'btnHold', 'btnClear', 'btnToggleHeatmap', 'btnHeatmapQuality', 'btnResetDba', 'btnClearAth', 'btnStartDemo',
          'fftSizePreset', 'smoothing', 'avg', 'aWeight', 'ec', 'ns', 'agc', 'themeSelector', 'fftRangeSlider',
          'fftPeakText', 'fftHoldText', 'octPeakText', 'octHoldText', 'heatmapAthText',
          'fftCanvas', 'octCanvas', 'heatmapCanvas', 'dbMeterCanvas',
          'fftTip', 'octTip', 'heatmapTip',
          'dbRealtimeValue', 'dbAvgValue', 'dbMaxValue',
          'calibrationOffset', 'octTitle', 'octRes',
          'octRangePreset', 'octRangeSlider', 'octRangeText',
          'heatmapRangeSlider', 'heatmapRangePreset', 'heatmapRangeText',
          'rms', 'peak', 'errBox', 'errMsg', 'secureStatus', 'permStatus', 'testResults'
        ];
        const dom = {};
        ids.forEach(id => dom[id] = document.getElementById(id));
        return dom;
      }

      setupEventListeners() {
        this.dom.btnStart.addEventListener('click', () => this.start());
        this.dom.btnStartDemo.addEventListener('click', () => this.startDemo());
        this.dom.btnStop.addEventListener('click', () => this.stop());
        this.dom.btnClear.addEventListener('click', () => this.clearPeak());
        this.dom.btnResetDba.addEventListener('click', () => this.resetDbaValues());
        
        this.dom.btnHold.addEventListener('click', () => {
          this.state.holdEnabled = !this.state.holdEnabled;
          this.dom.btnHold.setAttribute('aria-pressed', this.state.holdEnabled);
          this.dom.btnHold.textContent = `üìå Hold Peak: ${this.state.holdEnabled ? 'ON' : 'OFF'}`;
        });

        this.dom.btnToggleHeatmap.addEventListener('click', () => {
          this.state.heatmapEnabled = !this.state.heatmapEnabled;
          this.dom.btnToggleHeatmap.setAttribute('aria-pressed', this.state.heatmapEnabled);
          this.dom.btnToggleHeatmap.textContent = this.state.heatmapEnabled ? 'ON' : 'OFF';
          if (!this.state.heatmapEnabled) this.drawHeatmapOverlay();
        });
        
        this.dom.btnHeatmapQuality.addEventListener('click', () => {
          this.state.heatmapIsHD = !this.state.heatmapIsHD;
          this.dom.btnHeatmapQuality.setAttribute('aria-pressed', this.state.heatmapIsHD);
          this.dom.btnHeatmapQuality.textContent = this.state.heatmapIsHD ? 'HD' : 'SD';
          this.state.heatmapFreqBinMap = this.genHeatmapBins();
          this.state.heatmapData = [];
          if (this.state.heatmapEnabled) {
              this.drawHeatmap(true);
          } else {
              this.drawHeatmapOverlay();
          }
        });

        this.dom.btnClearAth.addEventListener('click', () => {
            this.state.athHeatmap = { value: -Infinity, bin: 0 };
            this.dom.heatmapAthText.textContent = 'ATH: ‚Äî';
        });

        this.dom.themeSelector.addEventListener('change', (e) => this.applyTheme(e.target.value));

        this.dom.fftSizePreset.addEventListener('change', (e) => {
            const selectedValue = e.target.value;
            const index = this.FFT_SIZES.indexOf(parseInt(selectedValue, 10));
            this.dom.fftRangeSlider.value = index;
            this.onConfigChange();
        });
        this.dom.fftRangeSlider.addEventListener('input', (e) => {
            const index = parseInt(e.target.value, 10);
            const fftSize = this.FFT_SIZES[index];
            this.dom.fftSizePreset.value = fftSize;
            this.onConfigChange();
        });
        
        this.dom.smoothing.addEventListener('input', () => {
          if (this.state.analyser) this.state.analyser.smoothingTimeConstant = parseFloat(this.dom.smoothing.value);
        });
        
        this.dom.octRes.addEventListener('change', () => {
            this.state.octN = parseInt(this.dom.octRes.value, 10);
            this.state.bands = this.genBands(this.state.octN);
            this.state.peakOct = new Float32Array(this.state.bands.length);
        });
        
        [this.dom.ec, this.dom.ns, this.dom.agc].forEach(el => el.addEventListener('change', () => {
            if (this.state.running) {
                this.stop();
                setTimeout(() => this.start(), 50);
            }
        }));
        
        this.dom.calibrationOffset.addEventListener('input', () => {
            this.state.calibrationOffset = parseFloat(this.dom.calibrationOffset.value) || 100;
        });

        this.dom.octRangePreset.addEventListener('change', (e) => {
            this.state.octRangeMax = parseInt(e.target.value, 10);
            this.dom.octRangeSlider.value = this.state.octRangeMax;
            this.updateOctaveRangeText();
        });
        this.dom.octRangeSlider.addEventListener('input', (e) => {
            this.state.octRangeMax = parseInt(e.target.value, 10);
            this.updateOctaveRangeText();
        });
        this.dom.heatmapRangePreset.addEventListener('change', (e) => {
            this.state.heatmapRangeMax = parseInt(e.target.value, 10);
            this.dom.heatmapRangeSlider.value = this.state.heatmapRangeMax;
            this.updateHeatmapRangeText();
        });
        this.dom.heatmapRangeSlider.addEventListener('input', () => {
            this.state.heatmapRangeMax = parseInt(this.dom.heatmapRangeSlider.value, 10);
            this.updateHeatmapRangeText();
        });
        
        window.addEventListener('resize', () => this.handleResize());
      }
      
      setupCanvases() {
          this.canvases = {
              fft: { canvas: this.dom.fftCanvas, ctx: this.dom.fftCanvas.getContext('2d'), tip: this.dom.fftTip },
              oct: { canvas: this.dom.octCanvas, ctx: this.dom.octCanvas.getContext('2d'), tip: this.dom.octTip },
              heatmap: { canvas: this.dom.heatmapCanvas, ctx: this.dom.heatmapCanvas.getContext('2d'), tip: this.dom.heatmapTip },
              dbMeter: { canvas: this.dom.dbMeterCanvas, ctx: this.dom.dbMeterCanvas.getContext('2d') }
          };
          this.handleResize();
          this.attachPressGuide(this.canvases.fft, 'fft');
          this.attachPressGuide(this.canvases.oct, 'oct');
          this.attachPressGuide(this.canvases.heatmap, 'heatmap');
      }

      handleResize() {
        const dpr = window.devicePixelRatio || 1;
        for (const key in this.canvases) {
            if (!this.canvases[key] || !this.canvases[key].canvas) continue;
            const { canvas, ctx } = this.canvases[key];
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            if (ctx) {
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.scale(dpr, dpr);
            }
        }
        this.drawInitialFrames();
        if (this.state.running) {
            this.drawFFT();
            this.drawOctave();
            if (this.state.heatmapEnabled) this.drawHeatmap(true);
        }
      }

      drawInitialFrames() {
        this.drawBackground(this.canvases.fft.ctx);
        this.drawBackground(this.canvases.oct.ctx);
        this.drawHeatmapBackground(this.canvases.heatmap.ctx);
        this.drawHeatmapOverlay();
        this.drawDbMeterBackground();
      }
      
      async start() {
        this.dom.btnStart.disabled = true;
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö getUserMedia API');
          }
          
          const constraints = { audio: { 
            echoCancellation: { ideal: this.dom.ec.checked },
            noiseSuppression: { ideal: this.dom.ns.checked },
            autoGainControl: { ideal: this.dom.agc.checked }
          }}; 

          let stream;
          try {
              stream = await navigator.mediaDevices.getUserMedia(constraints);
          } catch (e) {
              if (e && (e.name === 'NotAllowedError' || e.name === 'SecurityError')) {
                this.showError('‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô (NotAllowed).\n- ‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πâ HTTPS ‡∏´‡∏£‡∏∑‡∏≠ localhost\n- ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÑ‡∏°‡∏Ñ‡πå‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ\n- ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏î‡πÇ‡∏°‡πà" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡∏Ñ‡πå');
                this.dom.btnStart.disabled = false;
                return;
              }
              if (e && (e.name === 'NotFoundError' || e.name === 'OverconstrainedError')) {
                this.showError('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏°‡∏Ñ‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ');
                this.dom.btnStart.disabled = false;
                return;
              }
              try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
              } catch (e2) {
                this.showError(`‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÑ‡∏°‡∏Ñ‡πå‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: ${e2.message || e2}`);
                this.dom.btnStart.disabled = false;
                return;
              }
          }

          const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
          if (audioCtx.state === 'suspended') await audioCtx.resume();

          const analyser = audioCtx.createAnalyser();
          const micSrc = audioCtx.createMediaStreamSource(stream);
          micSrc.connect(analyser);

          this.state = { ...this.state, audioCtx, analyser, micSrc, stream, running: true, demo: { ...this.state.demo, enabled: false } };
          
          this.onConfigChange();
          this.resetDbaValues();
          this.dom.errBox.style.display = 'none';
          this.dom.btnStop.disabled = false;
          
          this.loop();

        } catch (err) {
          console.error(err);
          this.showError(err.message || String(err));
          this.dom.btnStart.disabled = false;
        }
      }

      async startDemo() {
        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
          if (audioCtx.state === 'suspended') await audioCtx.resume();

          const analyser = audioCtx.createAnalyser();
          const gain = audioCtx.createGain();
          gain.gain.value = 0;

          const osc1 = audioCtx.createOscillator(); osc1.type = 'sine'; osc1.frequency.value = 200;
          const osc2 = audioCtx.createOscillator(); osc2.type = 'sine'; osc2.frequency.value = 1000;
          const osc3 = audioCtx.createOscillator(); osc3.type = 'sine'; osc3.frequency.value = 5000;

          const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
          const data = noiseBuf.getChannelData(0);
          for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.02;
          const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf; noise.loop = true;

          osc1.connect(gain); osc2.connect(gain); osc3.connect(gain); noise.connect(gain);
          gain.connect(analyser);
          gain.connect(audioCtx.destination);

          osc1.start(); osc2.start(); osc3.start(); noise.start();

          let t = 0;
          const mod = () => {
            t += 0.016;
            osc1.frequency.value = 180 + 40 * Math.sin(t * 0.9);
            osc2.frequency.value = 900 + 150 * Math.sin(t * 0.7);
            osc3.frequency.value = 4500 + 600 * Math.sin(t * 0.5);
            if (this.state.running && this.state.demo.enabled) requestAnimationFrame(mod);
          };

          this.state = { ...this.state, audioCtx, analyser, micSrc: null, stream: null, running: true, demo: { enabled: true, oscillators: [osc1, osc2, osc3], noise, gain } };
          this.onConfigChange();
          this.resetDbaValues();
          this.dom.errBox.style.display = 'none';
          this.dom.btnStop.disabled = false;
          this.loop();
          mod();
        } catch (e) {
          this.showError('‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏î‡πÇ‡∏°‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: ' + (e.message || e));
        }
      }

      stop() {
        if (!this.state.running) return;
        this.state.running = false;
        cancelAnimationFrame(this.state.rafId);

        // ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡∏Ñ‡πå‡∏à‡∏£‡∏¥‡∏á
        this.state.stream?.getTracks().forEach(track => track.stop());
        this.state.micSrc?.disconnect();

        // ‡∏õ‡∏¥‡∏î‡πÄ‡∏î‡πÇ‡∏°‡πà
        if (this.state.demo.enabled) {
          this.state.demo.oscillators.forEach(o => { try { o.stop(); o.disconnect(); } catch(_){} });
          try { this.state.demo.noise.stop(); this.state.demo.noise.disconnect(); } catch(_){}
          try { this.state.demo.gain.disconnect(); } catch(_){}
        }

        this.state.analyser?.disconnect();
        try { this.state.audioCtx?.close(); } catch(_){}

        this.state = { ...this.state, audioCtx: null, analyser: null, micSrc: null, stream: null, demo: { enabled: false, oscillators: [], noise: null, gain: null } };
        
        this.dom.btnStart.disabled = false;
        this.dom.btnStop.disabled = true;
        this.dom.dbRealtimeValue.textContent = '‚Äî';
        this.updateDbMeter(-Infinity);
      }
      
      onConfigChange() {
          if (!this.state.analyser) return;
          this.state.analyser.fftSize = parseInt(this.dom.fftSizePreset.value, 10);
          this.state.analyser.smoothingTimeConstant = parseFloat(this.dom.smoothing.value);
          
          this.state.dataArray = new Uint8Array(this.state.analyser.fftSize);
          this.state.freqArray = new Uint8Array(this.state.analyser.frequencyBinCount);
          this.state.peakArray = new Uint8Array(this.state.analyser.frequencyBinCount);
          this.state.avgBuffer = new Float32Array(this.state.analyser.frequencyBinCount);
          
          this.state.sampleRate = this.state.audioCtx.sampleRate;
          this.state.bands = this.genBands(this.state.octN);
          this.state.peakOct = new Float32Array(this.state.bands.length);
          this.state.heatmapFreqBinMap = this.genHeatmapBins();
          this.state.heatmapData = [];
          this.state.athHeatmap = { value: -Infinity, bin: 0 };
      }

      loop() {
        if (!this.state.running) return;

        this.state.analyser.getByteTimeDomainData(this.state.dataArray);
        this.state.analyser.getByteFrequencyData(this.state.freqArray);
        
        if (this.dom.avg.checked) {
          const a = 0.5;
          for (let i = 0; i < this.state.freqArray.length; i++) {
            this.state.avgBuffer[i] = a * this.state.avgBuffer[i] + (1 - a) * this.state.freqArray[i];
            this.state.freqArray[i] = this.state.avgBuffer[i];
          }
        }
        
        this.drawFFT();
        this.drawOctave();
        this.updateRMS();
        this.updateDba();

        const now = performance.now();
        if (this.state.heatmapEnabled && (now - this.state.lastHeatmapUpdate >= 33)) {
          this.drawHeatmap();
          this.state.lastHeatmapUpdate = now;
        }

        this.state.rafId = requestAnimationFrame(() => this.loop());
      }
      
      clamp01(v) { return Math.min(1, Math.max(0, v)); }
      dbfs(v) { return 20 * Math.log10(v / 255 + 1e-12); }
      fmtHz(f) { return f >= 1000 ? ((f / 1000 >= 10 ? (f / 1000).toFixed(0) : (f / 1000).toFixed(1)) + ' kHz') : (Math.round(f) + ' Hz'); }
      aWeighting(f) { const f2 = f * f; const ra = (12200 ** 2 * f2 ** 2) / ((f2 + 20.6 ** 2) * (f2 + 12200 ** 2) * Math.sqrt((f2 + 107.7 ** 2) * (f2 + 737.9 ** 2))); return 20 * Math.log10(ra) + 2.0; }
      fmax() { return Math.min(this.state.sampleRate / 2, 20000); }
      mapLogX(f, w) { const fm = this.fmax(); const fmin = 20; const t = (Math.log10(Math.max(f, fmin)) - Math.log10(fmin)) / (Math.log10(fm) - Math.log10(fmin)); return this.PAD.L + t * (w - this.PAD.L - this.PAD.R); }
      xToFreq(x, w) { const fm = this.fmax(); const fmin = 20; const plotW = w - this.PAD.L - this.PAD.R; const t = this.clamp01((x - this.PAD.L) / plotW); const lf = Math.log10(fmin) + t * (Math.log10(fm) - Math.log10(fmin)); return Math.pow(10, lf); }
      mapDbToY(db, h) { const norm = this.clamp01((db + 100) / 100); const plotH = h - this.PAD.T - this.PAD.B; return this.PAD.T + (1 - norm) * plotH; }
      mapLinearToYOct(v, h) { const norm = this.clamp01(v / Math.max(1, this.state.octRangeMax)); const plotH = h - this.PAD.T - this.PAD.B; return this.PAD.T + (1 - norm) * plotH; }
      mapDbToColorHeatmap(db) {
          const maxDb = 0; const minDb = maxDb - this.state.heatmapRangeMax;
          const t = this.clamp01((db - minDb) / (maxDb - minDb));
          if (t < 0.25) return this.colors.heatmap[0]; if (t < 0.5) return this.colors.heatmap[1];
          if (t < 0.75) return this.colors.heatmap[2]; if (t < 0.9) return this.colors.heatmap[3];
          return this.colors.heatmap[4];
      }

      genBands(n) {
        const r = Math.pow(2, 1 / n), fm = this.fmax(), fmin = 20;
        const kmin = Math.ceil(Math.log(fmin / 1000) / Math.log(r));
        const kmax = Math.floor(Math.log(fm / 1000) / Math.log(r));
        const edgeHalf = Math.pow(2, 1 / (2 * n));
        const arr = [];
        for (let k = kmin; k <= kmax; k++) {
          const fc = 1000 * Math.pow(r, k), fl = fc / edgeHalf, fh = fc * edgeHalf;
          if (fh < fmin || fl > fm) continue;
          arr.push({ fc, fl: Math.max(fl, fmin), fh: Math.min(fh, fm) });
        }
        return arr;
      }

      genHeatmapBins() {
        if (!this.state.analyser) return null;
        const numBins = this.state.heatmapIsHD ? this.HEATMAP_BINS_HD : this.HEATMAP_BINS_SD;
        const fm = this.fmax(), fpb = this.state.sampleRate / this.state.analyser.fftSize, fmin = 20;
        const logFmin = Math.log10(fmin), logFmax = Math.log10(fm);
        const bins = [];
        for (let i = 0; i < numBins; i++) {
          const logFs = logFmin + (i / numBins) * (logFmax - logFmin);
          const logFe = logFmin + ((i + 1) / numBins) * (logFmax - logFmin);
          const fStart = Math.pow(10, logFs), fEnd = Math.pow(10, logFe);
          const binStart = Math.max(0, Math.floor(fStart / fpb));
          const binEnd = Math.min(this.state.analyser.frequencyBinCount - 1, Math.ceil(fEnd / fpb));
          bins.push({ binStart, binEnd, fStart, fEnd });
        }
        return bins;
      }
      
      drawBackground(ctx) {
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          ctx.clearRect(0, 0, plotW, plotH);
          const plotAreaH = plotH - this.PAD.T - this.PAD.B;
          ctx.strokeStyle = this.colors.gridH;
          for (let i = 0; i < 6; i++) { const y = this.PAD.T + (i / 5) * plotAreaH; ctx.beginPath(); ctx.moveTo(this.PAD.L, y); ctx.lineTo(plotW - this.PAD.R, y); ctx.stroke(); }
          ctx.strokeStyle = this.colors.gridV;
          const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
          ticks.forEach(t => { const x = this.mapLogX(t, plotW); ctx.beginPath(); ctx.moveTo(x, this.PAD.T); ctx.lineTo(x, this.PAD.T + plotAreaH); ctx.stroke(); });
          ctx.strokeStyle = this.colors.frame; ctx.strokeRect(this.PAD.L, this.PAD.T, plotW - this.PAD.L - this.PAD.R, plotAreaH);
          ctx.fillStyle = this.colors.label; ctx.font = '12px system-ui'; ctx.textBaseline = 'alphabetic';
          [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => { const x = this.mapLogX(t, plotW); ctx.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, plotH - this.LABEL_Y); });
      }

      /* ---------- Hold line + label helpers ---------- */
      roundedRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, h/2, w/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      drawPeakLine(ctx, x, h, color, dashed = false, labelText = null) {
        const y0 = this.PAD.T, y1 = h - this.PAD.B;
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        if (dashed) ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y1);
        ctx.stroke();
        ctx.restore();

        if (labelText) {
          // Draw pill label near the top, auto-clamped inside plot
          const plotLeft = this.PAD.L, plotRight = ctx.canvas.getBoundingClientRect().width - this.PAD.R;
          const ctxW = ctx.canvas.width / (window.devicePixelRatio || 1);
          const plotW = ctxW; // already using CSS pixels
          const padX = 6, padY = 4;
          ctx.save();
          ctx.font = '12px system-ui';
          const textW = ctx.measureText(labelText).width;
          let labelHalf = (textW + padX*2)/2;
          // clamp x so label stays in-frame
          let xLabel = x;
          if (xLabel - labelHalf < this.PAD.L + 2) xLabel = this.PAD.L + 2 + labelHalf;
          if (xLabel + labelHalf > plotW - this.PAD.R - 2) xLabel = plotW - this.PAD.R - 2 - labelHalf;
          const yLabel = this.PAD.T + 8;
          const rectX = xLabel - labelHalf, rectY = yLabel - (padY + 8), rectW = textW + padX*2, rectH = 18;

          // background pill
          ctx.fillStyle = 'rgba(0,0,0,.60)';
          ctx.strokeStyle = 'rgba(255,255,255,.22)';
          this.roundedRect(ctx, rectX, rectY, rectW, rectH, 8);
          ctx.fill();
          ctx.stroke();

          // small tick to the line
          ctx.beginPath();
          ctx.moveTo(x, rectY + rectH);
          ctx.lineTo(x, rectY + rectH + 6);
          ctx.strokeStyle = 'rgba(255,255,255,.35)';
          ctx.lineWidth = 1;
          ctx.stroke();

          // text
          ctx.fillStyle = '#e5e7eb';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(labelText, xLabel, rectY + rectH/2 + 0.5);
          ctx.restore();
        }
      }
      /* ---------------------------------------------- */
      
      drawFFT() {
          const { ctx } = this.canvases.fft;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          this.drawBackground(ctx);
          if (!this.state.freqArray) return;
          const N = this.state.freqArray.length, fpb = this.state.sampleRate / (2 * N);
          if (this.state.holdEnabled) {
              for (let i = 0; i < N; i++) this.state.peakArray[i] = Math.max(this.state.peakArray[i], this.state.freqArray[i]);
          }
          // live FFT curve
          ctx.beginPath(); let started = false;
          for (let i = 1; i < N; i++) {
              const f = i * fpb; if (f < 20 || f > this.fmax()) continue;
              const x = this.mapLogX(f, plotW), y = this.mapDbToY(this.dbfs(this.state.freqArray[i]), plotH);
              if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
          }
          ctx.strokeStyle = this.colors.fft; ctx.lineWidth = 2; ctx.stroke();
          // hold curve
          ctx.beginPath(); started = false;
          for (let i = 1; i < N; i++) {
              const f = i * fpb; if (f < 20 || f > this.fmax()) continue;
              const x = this.mapLogX(f, plotW), y = this.mapDbToY(this.dbfs(this.state.peakArray[i] || 0), plotH);
              if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y);
          }
          ctx.save(); ctx.globalAlpha = .35; ctx.strokeStyle = this.colors.peak; ctx.lineWidth = 1.25; ctx.stroke(); ctx.restore();

          // peak and hold bins
          let peakBin = 0, peakVal = -Infinity; 
          for (let i = 0; i < N; i++) if (this.state.freqArray[i] > peakVal) { peakVal = this.state.freqArray[i]; peakBin = i; }
          const peakFreqNow = peakBin * fpb;
          this.dom.peak.textContent = this.fmtHz(peakFreqNow);
          this.dom.fftPeakText.textContent = `Peak: ${this.fmtHz(peakFreqNow)}`;

          let holdBin = 0, holdVal = 0; 
          for (let i = 0; i < N; i++) if (this.state.peakArray[i] > holdVal) { holdVal = this.state.peakArray[i]; holdBin = i; }

          if (holdVal > 0) {
              this.dom.fftHoldText.style.display = '';
              const holdHz = holdBin * fpb;
              this.dom.fftHoldText.textContent = `Hold: ${this.fmtHz(holdHz)}`;
              this.drawPeakLine(ctx, this.mapLogX(holdHz, plotW), plotH, this.colors.hold, true, this.fmtHz(holdHz));
          } else {
              this.dom.fftHoldText.style.display = 'none';
          }
          // live peak guide (no label to avoid clutter)
          this.drawPeakLine(ctx, this.mapLogX(peakFreqNow, plotW), plotH, 'rgba(100,149,237,.6)');
          if (this.state.guideFFT) this.drawGuide(ctx, this.state.guideFFT.xPx, plotH);
      }

      drawOctave() {
          const { ctx } = this.canvases.oct;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          this.drawBackground(ctx);
          if (!this.state.freqArray || !this.state.bands.length) return;
          const N = this.state.freqArray.length, fpb = this.state.sampleRate / (2 * N);
          const vals = this.state.bands.map(b => {
              const s = Math.max(0, Math.floor(b.fl / fpb)), e = Math.min(N - 1, Math.ceil(b.fh / fpb));
              let sum = 0, cnt = 0;
              for (let i = s; i <= e; i++) { sum += this.state.freqArray[i]; cnt++; }
              let v = cnt ? (sum / cnt) : 0;
              if (this.dom.aWeight.checked) v *= Math.pow(10, this.aWeighting(b.fc) / 20);
              return v;
          });
          if (this.state.holdEnabled) {
              for (let i = 0; i < vals.length; i++) this.state.peakOct[i] = Math.max(this.state.peakOct[i], vals[i]);
          }
          // bars
          ctx.fillStyle = this.colors.bar;
          for (let i = 0; i < vals.length; i++) {
              const b = this.state.bands[i];
              const xL = this.mapLogX(b.fl, plotW), xR = this.mapLogX(b.fh, plotW);
              const barW = Math.max(2, xR - xL - 2);
              const y = this.mapLinearToYOct(vals[i], plotH);
              const barH = (plotH - this.PAD.B - y);
              ctx.fillRect(xL + 1, y, barW, Math.max(1, barH));
          }
          // hold spline
          ctx.beginPath();
          for (let i = 0; i < vals.length; i++) {
              const cx = this.mapLogX(this.state.bands[i].fc, plotW);
              const y = this.mapLinearToYOct(this.state.peakOct[i] || 0, plotH);
              if (i === 0) ctx.moveTo(cx, y); else ctx.lineTo(cx, y);
          }
          ctx.save(); ctx.globalAlpha = .45; ctx.strokeStyle = this.colors.hold; ctx.lineWidth = 1.5; ctx.stroke(); ctx.restore();

          // peak indices (now & hold)
          let idxNow = 0, vNow = -1; for (let i = 0; i < vals.length; i++) if (vals[i] > vNow) { vNow = vals[i]; idxNow = i; }
          let idxHold = 0, vHold = 0; for (let i = 0; i < this.state.peakOct.length; i++) if (this.state.peakOct[i] > vHold) { vHold = this.state.peakOct[i]; idxHold = i; }

          this.dom.octPeakText.textContent = `Peak: ${this.fmtHz(this.state.bands[idxNow].fc)}`;

          if (vHold > 0) {
              this.dom.octHoldText.style.display = '';
              const holdHz = this.state.bands[idxHold].fc;
              this.dom.octHoldText.textContent = `Hold: ${this.fmtHz(holdHz)}`;
              this.drawPeakLine(ctx, this.mapLogX(holdHz, plotW), plotH, this.colors.hold, true, this.fmtHz(holdHz));
          } else {
              this.dom.octHoldText.style.display = 'none';
          }
          // live peak guide (no label)
          this.drawPeakLine(ctx, this.mapLogX(this.state.bands[idxNow].fc, plotW), plotH, 'rgba(100,149,237,.6)');
          if (this.state.guideOCT) this.drawGuide(ctx, this.state.guideOCT.xPx, plotH);
      }

      drawHeatmap(forceRedraw = false) {
          const mainCtx = this.canvases.heatmap.ctx;
          const { width: w, height: h } = mainCtx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          const plotAreaH = plotH - this.PAD.B;

          if (!this.state.freqArray || !this.state.heatmapFreqBinMap) return;

          const frame = this.state.heatmapFreqBinMap.map(bin => {
              let sum = 0, cnt = 0;
              for (let j = bin.binStart; j <= bin.binEnd; j++) { sum += this.state.freqArray[j]; cnt++; }
              const avgDb = cnt > 0 ? this.dbfs(sum / cnt) : -100;
              return { db: avgDb };
          });
          
          let currentPeakBin = 0, currentPeakVal = -Infinity;
          for (let i = 0; i < frame.length; i++) {
              if (frame[i].db > currentPeakVal) { currentPeakVal = frame[i].db; currentPeakBin = i; }
          }
          if (currentPeakVal > this.state.athHeatmap.value) {
              this.state.athHeatmap = { value: currentPeakVal, bin: currentPeakBin };
          }

          const athFreqBin = this.state.heatmapFreqBinMap[this.state.athHeatmap.bin];
          if (athFreqBin && this.state.athHeatmap.value > -Infinity) {
              const athFreq = (athFreqBin.fStart + athFreqBin.fEnd) / 2;
              this.dom.heatmapAthText.textContent = `ATH: ${this.fmtHz(athFreq)}`;
          } else {
              this.dom.heatmapAthText.textContent = 'ATH: ‚Äî';
          }

          this.state.heatmapData.unshift(frame);
          if (this.state.heatmapData.length > this.HEATMAP_TIME_SLICES) {
              this.state.heatmapData.pop();
          }
          
          this.drawHeatmapBackground(mainCtx);
          const timeScale = plotAreaH / this.HEATMAP_TIME_SLICES;
          for (let i = 0; i < this.state.heatmapData.length; i++) {
              const y = i * timeScale;
              const row = this.state.heatmapData[i];
              for (let j = 0; j < row.length; j++) {
                  const { fStart, fEnd } = this.state.heatmapFreqBinMap[j];
                  const xL = this.mapLogX(fStart, plotW), xR = this.mapLogX(fEnd, plotW);
                  mainCtx.fillStyle = this.mapDbToColorHeatmap(row[j].db);
                  mainCtx.fillRect(xL, y, Math.max(1, xR - xL), timeScale);
              }
          }
          
          this.drawHeatmapGrid(mainCtx);
          if (this.state.guideHeatmap) this.drawHeatmapGuide(mainCtx, this.state.guideHeatmap.xPx, plotH);
      }
      
      drawHeatmapBackground(ctx) {
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        ctx.clearRect(0, 0, plotW, plotH);
      }

      drawHeatmapGrid(ctx) {
        const { width: w, height: h } = ctx.canvas;
        const dpr = window.devicePixelRatio || 1;
        const plotW = w / dpr, plotH = h / dpr;
        const plotAreaH = plotH - this.PAD.B;
        ctx.strokeStyle = this.colors.frame;
        ctx.strokeRect(this.PAD.L, 0, plotW - this.PAD.L - this.PAD.R, plotAreaH);
        ctx.strokeStyle = this.colors.gridV;
        const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
        ticks.forEach(t => { const x = this.mapLogX(t, plotW); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, plotAreaH); ctx.stroke(); });
        ctx.fillStyle = this.colors.label; ctx.font = '12px system-ui'; ctx.textBaseline = 'alphabetic';
        [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => { const x = this.mapLogX(t, plotW); ctx.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, plotH - this.LABEL_Y); });
      }

      drawHeatmapOverlay() {
          const { ctx } = this.canvases.heatmap;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          this.drawHeatmapBackground(ctx);
          ctx.fillStyle = 'rgba(255,255,255,.4)';
          ctx.font = '24px system-ui';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Heatmap OFF', plotW / 2, (plotH - this.PAD.B) / 2);
      }
      
      drawGuide(ctx, x, h) { ctx.save(); ctx.strokeStyle = 'rgba(100,149,237,.75)'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(x, this.PAD.T); ctx.lineTo(x, h - this.PAD.B); ctx.stroke(); ctx.restore(); }
      drawHeatmapGuide(ctx, x, h) { ctx.save(); ctx.strokeStyle = 'rgba(100,149,237,.75)'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h - this.PAD.B); ctx.stroke(); ctx.restore(); }

      updateRMS() { if (!this.state.dataArray) return; let sum = 0; for (let i = 0; i < this.state.dataArray.length; i++) { const v = (this.state.dataArray[i] - 128) / 128; sum += v * v; } const rms = Math.sqrt(sum / this.state.dataArray.length); this.dom.rms.textContent = (20 * Math.log10(rms + 1e-12)).toFixed(1) + ' dBFS'; }
      calculateDba() { if (!this.state.freqArray || !this.state.analyser) return -Infinity; const N = this.state.freqArray.length, fpb = this.state.sampleRate / this.state.analyser.fftSize; let sum = 0; for (let i = 0; i < N; i++) { const f = i * fpb; const aw = Math.pow(10, this.aWeighting(f) / 20); const v = this.state.freqArray[i] * aw; sum += v * v; } const rms = Math.sqrt(sum / N); const dbfsValue = 20 * Math.log10(rms / 255 + 1e-12); return dbfsValue + this.state.calibrationOffset; }
      drawDbMeterBackground() { const { ctx } = this.canvases.dbMeter; const { width: w, height: h } = ctx.canvas; ctx.clearRect(0, 0, w, h); }
      
      updateDbMeter(db) {
          const { ctx } = this.canvases.dbMeter;
          const { width: w, height: h } = ctx.canvas;
          const dpr = window.devicePixelRatio || 1;
          const plotW = w / dpr, plotH = h / dpr;
          const dbMin = 0, dbMax = 140;
          const fillW = plotW * this.clamp01((db - dbMin) / (dbMax - dbMin));
          const g = ctx.createLinearGradient(0, 0, plotW, 0);
          g.addColorStop(0, this.colors.dbMeter.green);
          g.addColorStop(0.357, this.colors.dbMeter.green);
          g.addColorStop(0.571, this.colors.dbMeter.yellow);
          g.addColorStop(0.714, this.colors.dbMeter.orange);
          g.addColorStop(0.785, this.colors.dbMeter.red);
          g.addColorStop(1, this.colors.dbMeter.red);
          this.drawDbMeterBackground();
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, fillW, plotH);
      }

      updateDba() {
          const dbAraw = this.calculateDba(), dbAdisp = Math.max(0, dbAraw);
          this.updateDbMeter(dbAdisp);
          if (this.state.dbaValues.length === 0) {
              if (dbAdisp > 0) {
                  this.state.dbaValues.push(dbAdisp);
                  this.dom.dbRealtimeValue.textContent = `${dbAdisp.toFixed(1)} dB`;
                  this.dom.dbAvgValue.textContent = this.dom.dbMaxValue.textContent = `${dbAdisp.toFixed(1)} dB`;
                  this.state.maxDba = dbAdisp;
              } else {
                  this.dom.dbRealtimeValue.textContent = '‚Äî'; this.dom.dbAvgValue.textContent = '‚Äî'; this.dom.dbMaxValue.textContent = '‚Äî';
              }
          } else {
              this.dom.dbRealtimeValue.textContent = `${dbAdisp.toFixed(1)} dB`;
              if (dbAdisp > this.state.maxDba) { this.state.maxDba = dbAdisp; this.dom.dbMaxValue.textContent = `${this.state.maxDba.toFixed(1)} dB`; }
              if (dbAdisp > 0) { this.state.dbaValues.push(dbAdisp); if (this.state.dbaValues.length > 100) this.state.dbaValues.shift(); }
              const avg = this.state.dbaValues.reduce((a, b) => a + b, 0) / this.state.dbaValues.length;
              this.dom.dbAvgValue.textContent = `${avg.toFixed(1)} dB`;
          }
      }

      resetDbaValues() { 
        this.state.maxDba = -Infinity; 
        this.state.dbaValues = []; 
        this.dom.dbRealtimeValue.textContent = '‚Äî'; 
        this.dom.dbAvgValue.textContent = '‚Äî'; 
        this.dom.dbMaxValue.textContent = '‚Äî'; 
      }

      clearPeak() { 
        if (this.state.peakArray) this.state.peakArray.fill(0); 
        if (this.state.peakOct) this.state.peakOct.fill(0); 
      }

      updateOctaveRangeText() { this.dom.octRangeText.textContent = `0‚Äì${this.state.octRangeMax}`; }
      updateHeatmapRangeText() { this.dom.heatmapRangeText.textContent = `-${this.state.heatmapRangeMax} dBFS`; }
      showError(msg) { this.dom.errBox.style.display = 'block'; this.dom.errMsg.textContent = msg; }
      
      attachPressGuide({ canvas, tip }, which) {
        let pressed = false;
        const getX = (e) => { const r = canvas.getBoundingClientRect(); const xCss = (e.touches ? e.touches[0].clientX : e.clientX) - r.left; return Math.max(this.PAD.L, Math.min(r.width - this.PAD.R, xCss)); };
        const update = (xPx) => {
            const freq = this.xToFreq(xPx, canvas.getBoundingClientRect().width);
            tip.style.display = 'block'; tip.textContent = this.fmtHz(freq);
            tip.style.left = xPx + 'px'; tip.style.top = '8px';
            const guideState = { xPx, freq };
            if (which === 'fft') this.state.guideFFT = guideState;
            else if (which === 'oct') this.state.guideOCT = guideState;
            else if (which === 'heatmap') this.state.guideHeatmap = guideState;
        };
        const clear = () => {
            pressed = false; tip.style.display = 'none';
            if (which === 'fft') this.state.guideFFT = null;
            else if (which === 'oct') this.state.guideOCT = null;
            else if (which === 'heatmap') this.state.guideHeatmap = null;
        };
        const onDown = (e) => { pressed = true; e.preventDefault(); update(getX(e)); };
        const onMove = (e) => { if (!pressed) return; e.preventDefault(); update(getX(e)); };
        const onUp = () => clear();
        canvas.addEventListener('mousedown', onDown); canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp); canvas.addEventListener('mouseleave', onUp);
        canvas.addEventListener('touchstart', onDown, { passive: false });
        canvas.addEventListener('touchmove', onMove, { passive: false });
        canvas.addEventListener('touchend', onUp);
      }

      applyTheme(themeName) {
        document.documentElement.dataset.theme = themeName;
        setTimeout(() => {
          this.updateColors();
          this.drawInitialFrames();
          if (this.state.running) {
            this.drawFFT();
            this.drawOctave();
            if (this.state.heatmapEnabled) this.drawHeatmap(true);
          }
        }, 50);
      }

      updateColors() {
        this.colors = {
          gridH: this.getStyle('--gridH'), gridV: this.getStyle('--gridV'),
          frame: this.getStyle('--frame'), label: this.getStyle('--label'),
          fft: this.getStyle('--fft'), peak: this.getStyle('--peak'),
          hold: this.getStyle('--hold'), bar: this.getStyle('--bar'),
          heatmap: [
            this.getStyle('--heatmap-color-1'), this.getStyle('--heatmap-color-2'),
            this.getStyle('--heatmap-color-3'), this.getStyle('--heatmap-color-4'),
            this.getStyle('--heatmap-color-5')
          ],
          dbMeter: {
            green: this.getStyle('--dba-meter-bg-green'),
            yellow: this.getStyle('--dba-meter-bg-yellow'),
            orange: this.getStyle('--dba-meter-bg-orange'),
            red: this.getStyle('--dba-meter-bg-red')
          }
        };
      }
    }

    new RTAnalyzer();

  })();
  </script>
</body>
</html>
